Title         : A*corral*ando Contractor.NET
Heading Base  : 2
Author        : Lean

[TITLE]

# Contractor
Ferto puto :)

# Corral
* Reachability Modulo Theories solver.
* Usa un CEGAR loop para tratar de encontrar alguna instancia de las variables
involucradas en el código a analizar que lleve a un bug.
* Usa stratified inlining para evitar la exploración exponencial del código al entrar en llamadas recursivas o a otros métodos. La idea es anular llamadas (To be continued)
* Usa under y over approximation (3 posibles resultados: True Bug, No Bugs, Recursion Bound Reached)
* Se basa fuertemente en la traducción del código .NET a Boogie que provee el 
proyecto BCT. Sin embargo, dicho proyecto mostró en reiteradas ocasiones fallar por no poder traducir.
En particular, la API de Code Contracts no esta completamente implementada y las instrucciones de Requires y Ensures tienen que ser traducidas como Assumes y Asserts.

## Corral como motor de decisión
El algoritmo principal de creación de EPAs sigue siendo el mismo que es utilizado con Code Contracts, propuesto en [Program Abstractions for Behaviour Validation][ICSE2011].

La primer diferencia que existe con la implementación de Code Contracts es que luego de generarse las queries y de ser incluidas en el assembly 
utilizado para ejecutarlas, dll que solo contiene la clase a analizar, tienen que pasar por una etapa de traducción.
Para esta traducción se utiliza el proyecto [BCT] que reescribe el código .NET en código Boogie.
Una vez que la traducción de la clase esta terminada, se realiza una llamada a Corral por cada query que se quiere analizar. Esta es una segunda diferencia
con Code Contracts, ya que este último requiere de una única llamada para analizar toda una clase. Esto se realiza de esta manera ya que Corral
necesita que se le especifique un único entrypoint a partir del cual empezar a analizar.

Dado que out-of-the-box Corral no provee un API para manipularlo, se modificó  el código de la aplicación de consola para que pueda ser llamado como un objeto de .NET. Además, como el resultado de la ejecución es originalmente mostrado por consola, se utilizó un enum para poder devolver cualquiera de los posibles resultados.
Dichos resultados pueden ser:

* "True bug": Corral encontró valores de variables para los cuales halló una traza que hace fallar un Assert
* "No bugs found (Proof computed)": Corral puedo probar que no hay ejecución posible que haga fallar los Asserts.
* "No bugs found (Proof not computed) aka. Recursion Bound Reached ": Corral no encontró bugs, sin embargo, tampoco puedo probar que no exista algún caso que falle, ya que alcanzo la cota de recursiones que está dispuesto a intentar.

Las queries se generan en dos momentos de la generación del EPA. La primer etapa es cuando se intenta responder a la pregunta _¿qué acciones quedan habilitadas si estoy en un estado 's' y ejecuto la acción 'a'?_

Para responder a esta pregunta se crea por cada acción a testear 't' una query positiva y otra negativa. Las queries positivas intentan probar que desde 's' ejecutando 'a' se puede probar la precondicion de 't'. Análogamente, las negativas intentan probar la negación de la precondicion de 't'.
Una vez generadas se realizan todas las llamadas correspondientes para analizarlas y obtener el resultado de Corral.

Para clasificar las acciones se crean dos conjuntos: *habilitadas* y *deshabilitadas*. Estos conjuntos contienen inicialmente todas las acciones.

Luego, se evalúa el resultado de cada query de la siguiente manera:

* Si el resultado es "No bugs (proof computed)", no se hace nada.
* Si el resultado es "True bug" o "Recursion Bound Reached"
  + y la query era positiva, no pude probar $inv(s) \land pre(a) \rightarrow pre(t)$, se quita 'a' de *habilitadas*.
  + y la query era negativa, no pude probar $inv(s) \land pre(a) \rightarrow \neg pre(t)$, se quita 'a' de *deshabilitadas*.

De esta manera, nos quedan definidos los conjuntos *habilitadas*, *deshabilitadas* y un grupo de acciones que no pertenecen a ninguno de los conjuntos anteriores.

Con estos conjuntos es posible definir todos los posibles estados alcanzables desde 's'.

La segunda etapa es para responder la pregunta ¿qué estados son efectivamente alcanzables si estoy en el estado 's' y ejecuto la acción 'a'?

En este caso, se crea una sola query negativa por cada tupla (origen, acción, destino). De manera similar el resultado de la ejecución de Corral se interpreta con las siguientes reglas:

* Si el resultado es "No bugs (proof computed)", no se agrega la transición al EPA.
* Si el resultado es "True bug", se agrega la transición al EPA.
* Si el resultado es "Recursion Bound Reached", se agrega la transición al EPA pero distinguida con '?' ya que no hay garantías de que sea posible ejercitarla.


# Propagar código para eliminar transiciones no factibles
La idea es eliminar transiciones que a pesar de ser lógicamente validas, son no factibles si se tiene en cuenta transiciones previas.
Esto puede pasar ya que de la forma en la que el EPA es generado, el testeo de las transiciones solo tiene en cuenta el invariante del estado del cual parte la transición y a cual pretende llegar. 

Si el invariante es mas débil de lo que en realidad el código puede probar podria suceder que aquellas configuraciones que habilitan dicha transicion no sean validas considerando un invariante mas fuerte.

Como motivacion consideremos la siguiente clase
~ Columns
~~ Column { width="30%" }
``` csharp
class CodePropagation01
{
    public int x { get; private set; }
    public int y { get; private set; }

    public CodePropagation01()
    {
        x = 0; y = 0;

    }

    public void m1()
    {
        Contract.Requires(x == 0 && y == 0);
        x = 5;
    }

```
~~
~~ Column
``` csharp
      
      
      ...
      
      public void m2()
      {
          Contract.Requires(x > 0 && y == 0);
          y = 7;
      }
  
      public void m3()
      {
          Contract.Requires(x == 5 && y == 7);
          x = 3; y = 3;
      }
  }
```
~~
~

Si generamos el EPA de `CodePropagation01`{language=csharp} el resultado que obtenemos es el que aparece a continuacion:

![code_test]

Como se puede observar, el estado *m2* permite probar dos posibles configuraciones, la primera en la que el unico metodo habilitado es el *m3* y otra en la que no hay metodos habilitados.
Si miramos detenidamente el codigo, podremos notar que los metodos *m1, m2, m3* estan pensados para ser ejecutados secuencialmente.

Entonces, ¿por que el EPA muestra que existe una alternativa a esta secuencia ($\{m2\}\rightarrow \{\})$?

El invariante de *m2*: $(x \neq 0 \lor y \neq 0) \land (x > 0 \land y = 0) \land (x \neq 5 \lor y \neq 7)$
Si consideramos este invariante como punto de partida, es cierto que uno puede probar los invariantes del estado *m3* y del estado vacio. Sin embargo, si consideramos que la **unica** forma de llegar al estado *m2* es a traves de la ejecucion del constructor y a continuacion el metodo m1, podemos reforzar dicho invariante con ($x = 5 \land y = 0$).
De esta forma, si volvemos a intentar probar la transicion $\{m2\} \rightarrow \{\}$ en esta oportunidad no vamos a poder lograrlo.

Luego, el EPA quedaria de la siguiente manera:

![code_test_post]

(Un caso mas grande, seguir escribiendo)

Ejemplo de EPA antes de ser procesada.

![code_motivation]

Luego de remover las transiciones no factibles.

![code_motivation_post]


##¿Como implementar esta propagacion?
Hint: Parto del invariante del estado inicial y hago una query que concatena todos los metodos que componen el camino desde el inicial al estado de la transicion que estoy tratando de probar.

¿Que pasa si el EPA no es aciclico? So far, no tengo idea :P

(Seguir escribiendo...)


[code_test]: images/code_test.png "code_test" { width=auto max-width=90% }
[code_test_post]: images/code_test_post.png "code_test_post" { width=auto max-width=90% }
[code_motivation]: images/code_motivation.png "code_motivation" { width=auto max-width=90% }
[code_motivation_post]: images/code_motivation_post.png "code_motivation_post" { width=auto max-width=90% }

[ICSE2011]: "http://publicaciones.dc.uba.ar/Publications/2011/DBGU11/paper-icse-2011.pdf" 
[BCT]: http://bytecodetranslator.codeplex.com